11-2-25 3:17pm i am just now beginning on Othello. I am going to use Java. I want to really abstract this out to make it easier to think through, so first I will be making a Piece and Board class and experiment first with just getting the game logic down. 
11-2-25 5:31pm i have a piece and board class. the piece class basically just holds a "color" which is a boolean since they are either white (true) or black (false). it has a method that "flips" it by negating the color field. the Board class has a board field that is a 2D piece array. how i want to structure the logic of this is to use a CLI with a chess board structure (something like A3, where A-H are columns, 1-8 are the rows). this allows for really basic indexing and we can just do conversion math. going to start on game logic now. i also googled how to clear a screen without a bunch of println calls (w reference)
11-4-25 6:47pm before i begin on this, i need to have a way to check if a move is legal before its possible. gonna make a method that just checks every possible violation with conditionals. i believe it should be as simple as passing the coordinates we wanna place a Piece at and then checking all around to see if its possible to maintain the rules of the game 
11-5-25 9:20am didnt record during but made progress on move legality checking. for any piece we want to place, there are 8 possible spots a piece of the opponents color can be. if/when we find one, we need to check further in that direction to see if we have another piece of our color at some point down that straight line. this entails going further past it in that direction (N, NE, E, SE, S, SW, W, NW) based on some for loop indexing that we do earlier. if we find that the move is valid, we also will flip all pieces that we encountered so far, because the move is legal and there is no point to do all of that board traversal more than once. ive traced through the logic with a drawing representation and i believe it all works. ive decided to scrap the flipping idea because that could get messy so instead i am just going to make another method that will be run to iterate through the board state once we know the move is legal and flip ALL possible pieces that need to be flipped. very similar logic to this one. starting on that now 
11-5-25 10:39am got the logic down for makeMove(). since it works on a lot of the same logic as checkMoveLegality. the only true difference is the return type (void) and the inner while loop. when we find the boundary piece, what we instead do is then start walking backwards down the path we were checking and adding each opposite colored piece between the boundary piece we found and the initial space we placed at. now going to work on fleshing out the actual gameplay logic and debugging potential errors in either of these methods. also changed my printBoard() logic to show column and row headers (like A3, B4, etc)
11-5-25 11:33am gameLoop() logic is mostly done now. debugging some things with how i am parsing user input since i am just using System.in and Scanner to retrieve the users line. some indexing problems with how i am converting the values from characters to strings. gonna work this out and then start looking for edge cases with how the game actually operates under my legality and move making methods 
11-5-25 11:36am after actually looking at the error being thrown i now realize its coming from this line that is checking bounds in checkMoveLegality. it is using board[i], which is -1 initially so that is not allowed. gonna change that line and keep testing after
11-5-25 11:39pm that fixed the big error i was having. now that i have the basic gameplay stuff down, i need to make a new method that is constantly checking at the beginning of each turn if there are possible moves to make. need to plan this out to see what this actually entails. my initial idea is just scanning with the piece we make at the beginning of each round to get its color and just checking each square to see if checkMoveLegality at every square returns either true or false, count the amount of times its true, and then check if that value is greater than 0 to see if that player can make a turn. only check if it == 0, and if it does just continue to the next person's turn and tell them they have no possible moves. i am also going to need to make a method that checks if either player can make a move at all, which may be similar logic but iterating through every possible space and maybe keeping two flags to check if either player can make a turn, and if either of them can the game keeps going, and then maybe check this at the end of every turn
11-5-25 12:04pm implemented checkMovesExist. it does the exact thing i said it should do. will probably do some testing later, but also wanna get started on implementing the gameOver() method that will check if any possible moves exist for either player and then count up the scores for each player. 
11-5-25 4:15pm a lot of work got done. implemented full checkMovesExist (which checks for a specific player) and checkAnyMovesExist (which checks for both players) and gameOver which just checks the scores of each player by iterating across the board and seeing who has more pieces and printing statements to say who won based on the scores. this is triggered every round after we check if 1.) the current player has any legal moves they can make and 2.) if either player has any moves that can be made. if neither player can make a legal move, gameOver is called. the game is functionally smooth as far as i can tell other than some input stuff that is tedious and not sure if i will worry about these bugs since they dont change the actual functionality of the game or the state of the game at any point. at this point, now it is time to start looking at the AI portion of all of this now that I have a good api to rest on, specifically the minimax algorithm which will i now start researching on and trying to better understand how to implement and waht it is doing 
11-6-25 2:03pm doing research on minimax and how to implement it. still not sure how to exactly understand it and even less sure how to actually implement it so i am going to potentially look at other implementations on the internet to make sense of how people are using this code to actually decision make. 
11-6-25 reference: https://www.datacamp.com/tutorial/minimax-algorithm-for-ai-in-python got some pseudocode in this that actually seems to be pretty close to checking whether any legal moves exist. i may alter this logic to accept a Piece so we can grab the color of it and pass that piece into the checkMoveLegality. it also appears i will need to make a way to copy the current board state since this pseudocode requires making moves for each empty spot. implemented copy() that just copies over the board state. this also includes making new pieces of the same color in those same spots because we also cannot reference the original pieces without messing with their state as well 
11-7-25 3:36pm going to work on actually implementing this. the pseudocode i found before does not work very well with moving it over to what i have so instead i am going to check the youtube video that is in the lecture notes to see if i can get a better idea of what i am working with. before that, i am going to ahead and let my heuristic be as simple as wanting to have more pieces than the other color (for the AI portion). i want to ensure it is as simple as possible to make it easy to integrate to the already functional game logic so that i dont end up messing up the guaranteed points i have lol 
11-7-25 3:51pm heuristic() returns an int which is just the difference between the amount of pieces we have (relative to when it is called and what piece color is passed into it) and the amount of pieces that are not our color, ignoring empty spaces (null). now to look at that youtube video 
11-7-25 4:04pm in watching this video i can already see some ways in which my code that worked fine for human vs. human gameplay was fine but will not function properly (or will not be as easy to implement) that i need to change. the first thing is that gameOver() in pseudocode is returning a boolean so i need to probably do the same, and since it seems that gameOver is a boolean, it must be that my logic for checkAnyMovesExist must be what gameOver should be doing instead. so i would then need to implement a separate method that finds the winner off of a board's current state that we can use in base case of minimax. i will first get to work on doing that 
11-7-25 4:40pm made checkAnyMovesExist into gameOver() and now have findWinner() which returns either -1, 0, or 1 based on whether black wins, game tied, or white wins. now working on implementing minimax based on the pseudocode and explanation which is making more sense now how the algorithm is actually "navigating" the search space with the recursive calls and minimize/maximize back and forth process which didnt make as much sense to me in class but now is mkaing more sense. i am altering this logic though to accept a specific color since we dont want the computer to ALWAYS be a specific color as we need to be able to opt into the computer playing for either player (white or black). working on getting this logic together now. 
11-7-25 5:11pm minimax finished. much simpler than i thought at first i just needed to wrap my head around what it was actually doing. it takes a depth, a Board object, a boolean maximizingPlayer and i added that it takes a boolean color. the color part is so we can take a heuristic when we reach our base case. possible redundant to have every call take color but safer than sorry even if it is wasteful. going to walk through it and try to see if i can find any bugs or unintentional behavior with pointers mutating values. after i do this, i will attempt to work this logic into the gameplay loop so that we can get a functional AI component of the game and work on getting that working well. 
11-7-25 10:01pm actually found a bug in my gameplay loop after having two people play an entire game. everything works logically and only legal moves were allowed the entire time including in edge cases like empty spaces that dont outflank. the bug was when there are no more legal moves for the current player to make (which would happen for both), i was using a continue instead of checking immediately after if isGameOver() returns true which we would need to see. so it entered an infinite loop of passing the turn immediately because neither player could play anything legal. this was fixed by simply removing that continue lol. before implementing the minimax algorithm into AI decision making in the gameplay loop, i am adding the ability to accept user input that changes the search depth to meet the additional requirements in the assignment details. after reading them a bunch, it seems i just need a constant in my gameplay loop that dictates what that max search depth is which initially will be set to 7. also added some error catching to this so that i can ensure that only integer values are passed and not decimal or character values. tomorrow will be spent integrating minimax properly into my gameplay loop so that we can have a functional AI counterpart to play against. after integrating it, then i will include the pruning functionality of the method which shouldnt be hard at all 
11-8-25 11:01am included some code so that the user can gracefully exit the game during the mainloop by entering "quit".  added toggling debugMode functionality and added a debugMode flag.  my thought process currently is that i am going to need a way to keep track of what moves are benefitting or hurting me the most so i need to make a method that iterates across the available spaces that minimax performs upon and returns the coordinates of the space that gave the greatest heuristic value. i will work now on implementing this since i need something that actually dictates if a move can be done. i will also implement the ability for either player to choose in the CLI if the AI plays for them, which will then just branch into the methods i am referring to 